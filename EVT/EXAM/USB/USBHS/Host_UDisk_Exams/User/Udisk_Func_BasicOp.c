/********************************** (C) COPYRIGHT *******************************
* File Name          : Udisk_Func_BasicOp.c
* Author             : WCH
* Version            : V1.0.0
* Date               : 2024/07/31
* Description        : USB full-speed port host operation functions.
*********************************************************************************
* Copyright (c) 2024 Nanjing Qinheng Microelectronics Co., Ltd.
* Attention: This software (modified or not) and binary are used for 
* microcontroller manufactured by Nanjing Qinheng Microelectronics.
*******************************************************************************/

/*******************************************************************************/
/* Header File */
#include "Udisk_Operation.h"
uint8_t  *pCodeStr;
/*******************************************************************************/
/* Variable Definition */
__attribute__((aligned(4)))  uint8_t  MY_DATA_BUF[ DISK_BASE_BUF_LEN ];   /* MY_DATA_BUF points to the disk data buffer of external RAM, the buffer length is the length of at least one sector, used for user data cache */
uint8_t  *pCodeStr;

/*********************************************************************
 * @fn      UDisk_USBH_ByteOperation
 *
 * @brief   Demo Function For UDisk File Byte-operation
 *          including Create\Modify\Read\Erase (EXAM1)
 *
 * @return  none
 */
void UDisk_USBH_ByteOperation( void )
{
    uint8_t ret;
    uint8_t i,t;
    uint16_t TotalCount = 0;

    UDisk_USBH_DiskReady( );
    if( (CHRV3DiskStatus >= DISK_MOUNTED)&&( UDisk_Opeation_Flag == 1 ) )
    {
        UDisk_Opeation_Flag = 0;
        printf("CHRV3DiskStatus:%02x\r\n",CHRV3DiskStatus);
        /* Read the file */
        strcpy( (char *)mCmdParam.Open.mPathName, "/NEWFILE.C" ); // Set the file path and file name to be operated /NEWFILE.C
        ret = CHRV3FileOpen( );                                       // Open the file
        if ( ret == ERR_MISS_DIR || ret == ERR_MISS_FILE )            // No file found
        {
            // Create a file demo
            printf( "Find No File And Create\r\n" );
            strcpy( (char *)mCmdParam.Create.mPathName, "/NEWFILE.C" );  // New file name, in the root directory, Chinese file name
            ret = CHRV3FileCreate( );                                        // Create a new file and open it. If the file already exists, delete it first and then create it.
            mStopIfError( ret );
            printf( "ByteWrite\r\n" );
            // In fact, it should be determined whether the length of the write data and the length of the definition buffer match. If it is greater than the length of the buffer, it needs to be written multiple times.
            i = sprintf( (char *)Com_Buffer,"Note: \xd\xa这个程序是以字节为单位进行U盘文件读写,简单演示功能。\xd\xa");
            for(t=0; t<10; t++)
            {
                mCmdParam.ByteWrite.mByteCount = i;                           // Specify the number of bytes written this time
                mCmdParam.ByteWrite.mByteBuffer = Com_Buffer;                 // Point to the buffer
                ret = CHRV3ByteWrite( );                                      // Write data to a file in bytes
                mStopIfError( ret );
                printf("成功写入 %02X次\r\n",(uint16_t)t);
            }
            // Demonstrate modifying file properties
            printf( "Modify\r\n" );
            mCmdParam.Modify.mFileAttr = 0xff;   // Input parameters: New file attribute, if it is 0FFH, it will not be modified.
            mCmdParam.Modify.mFileTime = 0xffff;   // Input parameters: If the new file time is 0FFFFH, it will not be modified. The default time generated by using the new file
            mCmdParam.Modify.mFileDate = MAKE_FILE_DATE( 2015, 5, 18 );  // Input parameters: New file date: 2015.05.18
            mCmdParam.Modify.mFileSize = 0xffffffff;  // Input parameters: New file length, writing files in bytes should be automatically updated when the library closes the file, so it will not be modified here
            i = CHRV3FileModify( );   // Modify the information of the current file, date of modification
            mStopIfError( i );
            printf( "Close\r\n" );
            mCmdParam.Close.mUpdateLen = 1;     // Automatically calculate file length and write files in bytes. It is recommended that the program library close the file so that the file length can be automatically updated.
            i = CHRV3FileClose( );
            mStopIfError( i );

            /* Delete a file */
//            printf( "Erase\n" );
// strcpy( (char *)mCmdParam.Create.mPathName, "/OLD" ); //The file name that will be deleted is in the root directory
// i = CHRV3FileErase( ); //Delete the file and close it
// if ( i != ERR_SUCCESS ) printf( "Error: %02X\n", (uint16_t)i ); //Express error
        }
        else
        {
            /* 1. Write to a file */
            printf( "ByteWrite\r\n" ); // If you want to add new data to the end of the original file, you can move the file pointer
            mCmdParam.ByteLocate.mByteOffset = 0xffffffff;  // Move to the end of the file
            CHRV3ByteLocate( );           // In fact, it should be determined whether the length of the write data and the length of the definition buffer match. If it is greater than the length of the buffer, it needs to be written multiple times.
            i = sprintf( (char *)Com_Buffer,"Note: \xd\xa这个程序是以字节为单位进行U盘文件读写,简单演示功能。\xd\xa"); // Presentation text
            for(t=0; t<10; t++)
            {
                mCmdParam.ByteWrite.mByteCount = i;               // Specify the number of bytes written this time
                mCmdParam.ByteWrite.mByteBuffer = Com_Buffer;     // Point to the buffer
                ret = CHRV3ByteWrite( );                          // Write data to a file in bytes
                mStopIfError( ret );
                printf("成功写入 %02X次\r\n",(uint16_t)t);
            }
            /* 2. Read the first N bytes of the file */
            TotalCount = 60;                                                  // Set ready to read a total length of 100 bytes
            strcpy( (char *)mCmdParam.Open.mPathName, "/NEWFILE.C" );     // Set the file path and file name to be operated /NEWFILE.C
            CHRV3FileOpen( );                                                 // Open the file
            printf( "读出的前%d个字符是:\r\n",TotalCount );
            while ( TotalCount )
            {
                // If the file is large and cannot be read at once, you can call CH103ByteRead to continue reading, and the file pointer will automatically move backwards.
                if ( TotalCount > (MAX_PATH_LEN-1) )
                {
                    t = MAX_PATH_LEN-1; // There is a lot of remaining data, and the length of a single read and write cannot exceed sizeof( mCmdParam.Other.mBuffer )
                }
                else
                {
                    t = TotalCount; // The last remaining number of bytes
                }
                mCmdParam.ByteRead.mByteCount = t;                   // Request to read out several tens of bytes of data
                mCmdParam.ByteRead.mByteBuffer= &Com_Buffer[0];
                ret = CHRV3ByteRead( );                              // Read data blocks in units of bytes. The length of a single read and write cannot exceed MAX_BYTE_IO. The second call will follow the backward reading just now.
                TotalCount -= mCmdParam.ByteRead.mByteCount;         // Count, subtract the number of characters that have been read
                for ( i=0; i!=mCmdParam.ByteRead.mByteCount; i++ )
                {
                    printf( "%c", mCmdParam.ByteRead.mByteBuffer[i] ); // Show read characters
                }
                printf( "\r\n" );

                if ( mCmdParam.ByteRead.mByteCount < t ) // The actual number of characters read is less than the number of characters required to be read, which means that it has reached the end of the file.
                {
                    printf( "\r\n" );
                    printf( "文件已经结束\r\n" );
                    break;
                }
            }
            i = CHRV3FileClose( ); // Close the file
            mStopIfError( i );
        }
    }
}

/*********************************************************************
 * @fn      UDisk_USBH_SectorOperation
 *
 * @brief   Demo Function For UDisk File Sector-operation
 *          including Create\Modify\Read\Erase (EXAM6)
 *
 * @return  none
 */
void UDisk_USBH_SectorOperation( void )
{
    uint8_t  ret, SecCount, s;
    uint8_t  i;
    uint16_t tmp;
    uint8_t  tmpbuf[64];

    ret = UDisk_USBH_DiskReady( );
    if( ( ret == DISK_READY )&&( UDisk_Opeation_Flag == 1 ) )
    {
        UDisk_Opeation_Flag = 0;
        /* Query the physical capacity of the disk */
        printf( "DiskSize\r\n" );
        i = CHRV3DiskQuery( );
        mStopIfError( i );
        printf( "TotalSize = %u MB \n", (unsigned int)( mCmdParam.Query.mTotalSector * CHRV3vSectorSizeB / 2 ) );  // Displayed as capacity in MB

        /* Read the original file */
        printf( "Open\r\n" );
        strcpy( mCmdParam.Open.mPathName, "/NEWFILE.TXT" );// File name, the file is in the C51 subdirectory
        s = CHRV3FileOpen( );                       // Open the file
        if ( s == ERR_MISS_DIR || s == ERR_MISS_FILE )// No file found
        {
            printf( "没有找到文件\r\n" );
        }
        else                                        // File found or error occurred
        {
            printf( "Query\r\n" );
            i = CHRV3FileQuery( );                  // Query the information of the current file
            mStopIfError( i );
            printf( "Read\r\n" );
            CHRV3vFileSize = CHRV3vFileSize+(sizeof( MY_DATA_BUF )-1);    // The length of the original file
            SecCount = CHRV3vFileSize/ sizeof( MY_DATA_BUF )  ;// Calculate the number of sectors of the file. Because reading and writing are based on sectors, add CHRV3vSectorSize-1 first to read out the part of the end of the file with less than 1 sector.
            printf( "Size=%ld, Sec=%d\r\n", CHRV3vFileSize, (uint16_t)SecCount );
            while(SecCount--)
            {
                mCmdParam.Read.mSectorCount = sizeof( MY_DATA_BUF )/512;  // Read all data. If there are more than 2 sectors, only 2 sectors will be read.
                mCmdParam.Read.mDataBuffer = &MY_DATA_BUF[0];// Point to the start address of the file data buffer
                i = CHRV3FileRead( );                    // Read data from a file
                mStopIfError( i );
                if(SecCount == 0) break;
                /*
                for(tmp=0; tmp<sizeof( MY_DATA_BUF ); tmp++)
                {
                printf("%02X ",(uint16_t)MY_DATA_BUF[tmp]);
                }
                printf("\n");
                */
            }
            tmp = (CHRV3vFileSize-(sizeof( MY_DATA_BUF )-1))%sizeof( MY_DATA_BUF );
            if((tmp == 0)&&(CHRV3vFileSize != 0)) tmp = sizeof( MY_DATA_BUF );
            CHRV3vFileSize = CHRV3vFileSize-(sizeof( MY_DATA_BUF )-1);    // Restore the length of the original file
            /*
            for(i=0; i<tmp; i++)
            {
              printf("%02X ",(uint16_t)MY_DATA_BUF[i]);
            }
            printf("\n");
            */
            /* If the file is large and cannot be finished reading at once, you can call CHRV3FileRead to continue reading, and the file pointer will automatically move backwards.
             While ( 1 )
             {
               c = 4; Each time 4 sectors are read, the larger the buffer definition, the more sectors are read at a time
               mCmdParam.Read.mSectorCount = c; Specifies the number of read sectors
               mCmdParam.Read.mDataBuffer = &MY_DATA_BUF[0]; Point to the start address of the file data buffer
               CHRV3FileRead(); After reading, the file pointer is automatically moved backwards to process data
               if ( mCmdParam.Read.mSectorCount < c ) break; If the actual number of sectors read is small, it means that the file has ended
             }
                                               If you want to start reading and writing from a specified location, you can move the file pointer
              mCmdParam.Locate.mSectorOffset = 3; Skip the first 3 sectors of the file and start reading and writing
              i = CHRV3FileLocate( );
              mCmdParam.Read.mSectorCount = 10;
              mCmdParam.Read.mDataBuffer = &MY_DATA_BUF[0]; Point to the start address of the file data buffer
              CHRV3FileRead(); directly reads data starting from the (CHRV3vSectorSizeH*256*3) bytes of the file, and the first 3 sectors are skipped
                                               If you want to add new data to the end of the original file, you can move the file pointer
              i = CHRV3FileOpen( );
              mCmdParam.Locate.mSectorOffset = 0xffffffff; Move to the end of the file, in sectors, if the original file is 3 bytes, it will be added from CHRV3vSectorSizeH bytes
              i = CHRV3FileLocate( );
              mCmdParam.Write.mSectorCount = 10;
              mCmdParam.Write.mDataBuffer = &MY_DATA_BUF[0];
              CHRV3FileWrite(); Add data after the original file
                                               Use CHRV3FileRead to define the starting address of the data buffer by yourself
              mCmdParam.Read.mSectorCount = 2;
              mCmdParam.Read.mDataBuffer = 0x50; Put the read data into the buffer starting at 50H, and you need to specify the start address of the buffer
              CHRV3FileRead(); Read 2 sectors from the file to the specified buffer
                                                Use CHRV3FileWrite to define the starting address of the data buffer by yourself
              mCmdParam.Wiite.mSectorCount = 2;
              mCmdParam.Write.mDataBuffer = 0x50; Write data in the buffer starting from 50H to
              CHRV3FileWrite(); Writes data in the specified buffer to 2 sectors into the file */
            printf( "Close\r\n" );
            i = CHRV3FileClose( );                            // Close the file
            mStopIfError( i );
        }
        printf( "Create\r\n" );
        strcpy( mCmdParam.Create.mPathName, "/NEWFILE.TXT" );// New file name, in the root directory, Chinese file name
        s = CHRV3FileCreate( );                               // Create a new file and open it. If the file already exists, delete it first and then create it */
        mStopIfError( s );
        printf( "Write\r\n" );
        strcpy( tmpbuf, "0000ABCDEFGHIJKLMNOPQRSTUVWXYZ\xd\xa" );// Prepare to write file data
        for(i=0; i<(DISK_BASE_BUF_LEN/sizeof(tmpbuf)); i++)
        {
            tmp=i*sizeof(tmpbuf);
            strcpy(&MY_DATA_BUF[tmp],tmpbuf);
        }
        for(tmp=0; tmp<sizeof(MY_DATA_BUF); tmp++)
        {
            printf("%02X",(uint16_t)MY_DATA_BUF[tmp]);
        }
        printf("\r\n");
        for(s=0; s<10; s++)
        {
            mCmdParam.Write.mSectorCount = 1;                 // Write data to all sectors
            mCmdParam.Write.mDataBuffer = &MY_DATA_BUF[0];    // Point to the start address of the file data buffer
            i = CHRV3FileWrite( );                            // Write data to a file
            mStopIfError( i );
            printf("成功写入 %02X次\r\n",(uint16_t)s);
        }
        /* printf( "Modify\n" );
           mCmdParam.Modify.mFileAttr = 0xff; Input parameters: New file attribute, if it is 0FFH, it will not be modified
           mCmdParam.Modify.mFileTime = 0xffff; Input parameters: If the new file time is 0FFFFH, it will not be modified. The default time generated by using the new file is created
           mCmdParam.Modify.mFileDate = MAKE_FILE_DATE( 2015, 5, 18 ); Input parameters: New file date: 2015.05.18
           mCmdParam.Modify.mFileSize = 0xffffffff; Input parameters: New file length, writing files in bytes should be automatically updated when the library closes the file, so it will not be modified here
           i = CHRV3FileModify( ); Modify the information of the current file, modify the date
           mStopIfError( i ); */
        printf( "Close\r\n" );
        mCmdParam.Close.mUpdateLen = 1;                        // Automatically calculate file length and write files in bytes. It is recommended that the program library close the file so that the file length can be automatically updated.
        i = CHRV3FileClose( );
        mStopIfError( i );
        /* Delete a file */
        /* printf( "Erase\n" );
          strcpy( mCmdParam.Create.mPathName, "/OLD.TXT" ); The deleted file name is in the root directory
          i = CHRV3FileErase( ); Delete the file and close it
          if ( i != ERR_SUCCESS ) printf( "Error File not exist: %02X\n", (uint16_t)i); display error */
        printf( "U盘演示完成\r\n" );
    }
}


/*********************************************************************
 * @fn      UDisk_USBH_EnumFiles
 *
 * @brief   Demo Function For Enumerating files in UDisk(EXAM11)
 *
 * @return  none
 */
void UDisk_USBH_EnumFiles( void )
{
    uint8_t  i, s, ret;
    uint16_t j;

    ret = UDisk_USBH_DiskReady( );
    if( ( ret == DISK_READY )&&( UDisk_Opeation_Flag == 1 ) )
    {
        UDisk_Opeation_Flag = 0;
        /* Read the original file */
        printf( "Open\r\n" );
        strcpy( mCmdParam.Open.mPathName, "/C51/CHRV3HFT.C" );// File name, the file is in the C51 subdirectory
        s = CHRV3FileOpen( );                        // Open the file
        /* List files */
        if ( s == ERR_MISS_DIR )
        {
            printf("不存在该文件则列出所有文件\r\n");  // The C51 subdirectory does not exist, and all files in the root directory are listed.
            pCodeStr = "/* ";
        }
        else
        {
            pCodeStr = "/C51/*"; // If the CHRV3HFT.C file does not exist, then list the files starting with CHRV3 in the \C51 subdirectory
        }
        printf( "List file %s\r\n", pCodeStr );
        for ( j = 0; j < 10000; j ++ ) // Search for the top 10000 files at most, there is actually no limit
        {
            strcpy( (char *)mCmdParam.Open.mPathName, pCodeStr );//Search for file name, * is a wildcard character, applicable to all files or subdirectories
            i = strlen( mCmdParam.Open.mPathName );
            mCmdParam.Open.mPathName[ i ] = 0xFF; // Replace the ending character with the search sequence number according to the length of the string, from 0 to 254. If it is 0xFF, that is, 255, it means that the search sequence number is in the CHRV3vFileSize variable
            CHRV3vFileSize = j; //Specify the sequence number of search/enum
            i = CHRV3FileOpen( ); //Open the file. If the file name contains wildcard characters*, it will not open it to search for the file.
            /* The only difference between CHRV3FileEnum and CHRV3FileOpen is that when the latter returns ERR_FOUND_NAME, it returns ERR_SUCCESS corresponding to the former */
            if ( i == ERR_MISS_FILE )
            {
                break;                                // No matching file can be searched anymore, no matching file name is available
            }
            if ( i == ERR_FOUND_NAME )
            {
                /* Search for file names matching wildcard characters, file names and their full paths in the command buffer */
                printf( "  match file %04d#: %s\r\n", (unsigned int)j, mCmdParam.Open.mPathName );// Display the serial number and the searched matching file name or subdirectory name
                continue;                             // Continue to search for the next matching file name, and the next time you search, the serial number will be added 1
            }
            else
            {
                /* An error occurred */
                mStopIfError( i );
                break;
            }
        }
        printf( "Close\r\n" );
        CHRV3FileClose( );                            // Close the file
        printf( "U盘演示完成\r\n" );
    }
}
